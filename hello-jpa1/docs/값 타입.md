## JPA의 데이터 타입 분류

- 엔티티 타입
  - `@Entity` 로 정의하는 객체
  - 데이터가 변해도 식별자로 지속해서 추적 가능
- 값 타입
  - int, Integer, String처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체
  - 식별자가 없고 값만 있으므로 변경시 추적 불가

## 값 타입 분류

- 기본값 타입
  - 자바 기본 타입(primitive type) : int, double
  - 래퍼 클래스(wrapper class) : Integer, Long
  - String
- 임베디드 타입(embedded type, 복합 값 타입)
- 컬렉션 값 타입(collection value type)
<br>: Java Collection 에 기본 값 타입이나 임베디드 타입을 넣을 수 있는 것

<br>

### 기본값 타입

- String, int, Long 등
- 생명주기를 엔티티에 의존
- 값 타입은 공유하면 X
  - 참고로 자바의 기본 타입(primitive type)은 절대 공유 X
    - 기본 타입은 항상 값을 복사하기 때문
  - Integer 같은 래퍼 클래스나 String 같은 특수한 클래스는 공유 가능한 객체이지만 변경 X
    - 클래스는 레퍼런스(참조값)을 가지고 있기 때문

---

## 값 타입과 불변 객체

### 값 타입 공유 참조

- 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험하다
  - 만약 같은 Address 를 여러 엔티티에서 공유하고 싶다면, 값 타입이 아닌 엔티티를 사용하는 것이 맞다
- 값 타입 공유가 가능하기 때문에 side effect(부작용)이 발생할 수 있다
  - 회원1과 회원2가 같은 Address 를 사용한다고 할 때, 회원1의 Address 값을 변경하면 회원1과 회원2 모두 변경된다

### 값 타입 복사, 객체 타입의 한계

- 값 타입의 실제 인스턴스인 값을 공유하는 것은 위험하다
- 대신 값(인스턴스)를 복사해서 사용해야 한다
  - 항상 값을 복사해서 사용하면 공유 참조로 인한 부작용을 피할 수 있다

<br>

- 문제는 임베디드 타입처럼 직접 정의한 값 타입은 자바의 기본 타입이 아닌 객체 타입이다
  - 자바 기본 타입(primitive type)에 값을 대입하면 항상 값을 복사한다
- 객체 타입은 참조 값을 직접 대입하는 것을 막을 수 없다
  - 즉, 객체의 공유 참조는 피할 수 없다

`기본 타입(primitive type)`
```java
int a = 10;
int b = a;  // 기본 타입은 값을 복사한다

b = 4;  // a : 10, b : 4
```

`객체 타입`
```java
Address a = new Address("Old");
Address b = a;  // 객체 타입은 참조를 전달

b.setCity("New");  // a : New, b : New
```

a와 b가 같은 Address 인스턴스를 가리키기 때문에 b.setCity() 를 통해 a와 b 모두 값이 변경되는 것이다

## 불변 객체

- 객체 타입을 아예 수정할 수 없게 만들면 부작용을 원천 차단할 수 있다
- 값 타입은 불변 객체(immutable object)로 설계해야 한다!
  - 불변 객체 : 생성 시점 이후 절대 값을 변경할 수 없는 객체

- 생성자로만 값을 설정하고 수정자(setter)를 만들지 않으면 된다
  - 혹은 setter 를 private 으로 만들어 내부에서만 사용하는 방식을 택할 수도 있다
- 참고로 Integer, String은 자바가 제공하는 대표적인 불변 객체이다

<br>

> 값 타입은 불변 객체로 설계해서 side effect 를 방지해야 한다!

- 만약 값을 바꾸고 싶다면 새로 값 타입 객체를 만들어서 넣어주어야 한다
  - 값 타입이므로 Address 객체를 새로 만들어 통으로 갈아끼우는 게 맞다
```java
Address address = new Address("city", "street", "zipcode");
Member member = new Member();
member.setName("member1");
member.setHomeAddress(address);
em.persist(member);

Address newAddress = new Address("NewCity", address.getStreet(), address.getZipCode());
member.setHomeAddress(newAddress);
```

## 값 타입의 비교

- 동일성 비교 : 인스턴스의 참조 값을 비교, `==` 사용
- 동등성 비교 : 인스턴스의 값을 비교, `equals()` 사용

- 값 타입은 equals() 를 사용해서 동등성 비교를 해야 한다
- 따라서 값 타입의 equals() 메서드를 적절하게 재정의(주로 모든 필드 사용)해야 한다

```java
@Override
public boolean equals(Object o) {  // 값 타입의 비교를 위해 equals()를 오버라이딩해야 함
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    Address address = (Address) o;
    return Objects.equals(getCity(), address.getCity()) &&
        Objects.equals(getStreet(), address.getStreet()) &&
        Objects.equals(getZipcode(), address.getZipcode());
}

@Override
public int hashCode() {
    return Objects.hash(getCity(), getStreet(), getZipcode());
}
```

> 자바의 primitive type 은 == 비교를 해도 되지만,<br>
> 나머지 값 타입들(특히, Embedded type 같이 직접 정의한 값 타입)은 모두 equals() 를 오버라이딩 해서 동등성 비교를 해야 한다
